---
title: Create models
permalink: /getting-started/core/create-models
category: Getting Started
subCategory: Core
menuOrder: 5
isDisableFeedbackBlock: true
redirect_from:
  - /schema/getting-started
  - /getting-started-cubejs-schema
---

<InfoBox>
  We're excited to expand the beta of YAML and Python support in Cube data
  modeling. <br />
  Please <a href="https://forms.gle/4CZRRKK8nD4PvtxZA">
    {' '}
    reach out to us{' '}
  </a> if you’d like to sign up for early access.
</InfoBox>

A Cube model is used to translate raw data into meaningful business definitions
and pre-aggregate data for optimal results. The model is exposed through the
[querying API][ref-backend-restapi] that allows end-users to query a wide
variety of analytical queries without modifying the model itself.

In the previous step, we connected Cube to our data source and generated models.
Here, we'll learn how to create a model from scratch using the `users` table
from the sample e-commerce dataset.

Let’s look at a sample of the `users` table:

| id  | paying | city          | company_name |
| --- | ------ | ------------- | ------------ |
| 1   | true   | San Francisco | Pied Piper   |
| 2   | true   | Palo Alto     | Raviga       |
| 3   | true   | Redwood       | Aviato       |
| 4   | false  | Mountain View | Bream-Hall   |
| 5   | false  | Santa Cruz    | Hooli        |

We can start with a set of simple questions about users we want to answer:

- How many users do we have?
- How many paying users?
- What is the percentage of paying users out of the total?
- How many users, paying or not, are from different cities and companies?

We don’t need to write SQL queries for every question, since the model allows
building well-organized and reusable SQL.

## Create a Cube

In Cube, [cubes][ref-schema-cube] are used to organize entities and connections
between entities. Usually one cube is created for each table in the database,
such as `users`, `orders`, `products`, etc. In the `sql` parameter of the cube
we define a base table for this cube. In our case, the base table is simply our
`users` table.

<CodeTabs>

```javascript
cube(`Users`, {
  sql: `SELECT * FROM users`,
});
```

```yaml
cubes:
  - name: Users
    sql: SELECT * FROM users
```

</CodeTabs>

## Add measures and dimensions

Once the base table is defined, the next step is to add
[measures][ref-schema-measures] and [dimensions][ref-schema-dimensions] to the
cube.

<InfoBox>

**Measures** are referred to as quantitative data, such as number of units sold,
number of unique visits, profit, and so on.

**Dimensions** are referred to as categorical data, such as state, gender,
product name, or units of time (e.g., day, week, month).

</InfoBox>

Let's go ahead and create our first measure and two dimensions:

<CodeTabs>

```javascript
cube(`Users`, {
  sql: `SELECT * FROM users`,

  measures: {
    count: {
      sql: `id`,
      type: `count`,
    },
  },

  dimensions: {
    city: {
      sql: `city`,
      type: `string`,
    },

    company_name: {
      sql: `company_name`,
      type: `string`,
    },
  },
});
```

```yaml
cubes:
  - name: Users
    sql: SELECT * FROM users
    measures:
      - name: count
        sql: id
        type: count
    dimensions:
      - name: city
        sql: city
        type: string
      - name: company_name
        sql: company_name
        type: string
```

</CodeTabs>

Let's break down the above code snippet piece-by-piece. After defining the base
table for the cube (with the `sql` property), we create a `count` measure in the
`measures` block. [The type][ref-schema-types-formats] `count` and sql `id`
means that when this measure will be requested via an API, Cube will generate
and execute the following SQL:

```sql
SELECT count(id) from users;
```

When we apply a city dimension to the measure to see "Where are users based?",
Cube will generate SQL with a `GROUP BY` clause:

```sql
SELECT city, count(id) from users GROUP BY 1;
```

You can add as many dimensions as you want to your query when you perform
grouping.

## Add filters to measures

Now let's answer the next question – "How many paying users do we have?". To
accomplish this, we will introduce **measure filters**:

<CodeTabs>

```javascript
cube(`Users`, {
  measures: {
    count: {
      sql: `id`,
      type: `count`,
    },

    paying_count: {
      sql: `id`,
      type: `count`,
      filters: [{ sql: `${CUBE}.paying = 'true'` }],
    },
  },
});
```

```yaml
cubes:
  - name: Users
    measures:
      - name: count
        sql: id
        type: count
      - name: paying_count
        sql: id
        type: count
        filters:
          - sql: "{CUBE}.paying = 'true'"
```

</CodeTabs>

<InfoBox>

It is best practice to prefix references to table columns with the name of the
cube or with the `CUBE` constant when referencing the current cube's column.

</InfoBox>

That's it! Now we have the `paying_count` measure, which shows only our paying
users. When this measure is requested, Cube will generate the following SQL:

```sql
SELECT
  count(
    CASE WHEN (users.paying = 'true') THEN users.id END
  ) "users.paying_count"
FROM users
```

Since the `filters` property is an array, you can apply as many filters as
required. `paying_count` can be used with dimensions the same way as a simple
`count`. We can group `paying_count` by `city` and `companyName` simply by
adding these dimensions alongside measures in the requested query.

## Using calculated measures

To answer "What is the percentage of paying users out of the total?", we need to
calculate the paying users ratio, which is basically `paying_count / count`.
Cube makes it extremely easy to perform this kind of calculation. Let's add a
new measure to our cube called `paying_percentage`:

<CodeTabs>

```javascript
cube(`Users`, {
  measures: {
    count: {
      sql: `id`,
      type: `count`,
    },

    paying_count: {
      sql: `id`,
      type: `count`,
      filters: [{ sql: `${CUBE}.paying = 'true'` }],
    },

    paying_percentage: {
      sql: `100.0 * ${paying_count} / ${count}`,
      type: `number`,
      format: `percent`,
    },
  },
});
```

```yaml
cubes:
  - name: Users
    measures:
      - name: count
        sql: id
        type: count
      - name: paying_count
        sql: id
        type: count
        filters:
          - sql: "{CUBE}.paying = 'true'"
      - name: paying_percentage
        sql: '100.0 * {paying_count} / {count}'
        type: number
        format: percent
```

</CodeTabs>

Here we defined a calculated measure `paying_percentage`, which divides
`paying_count` by `count`. This example shows how you can reference measures
inside other measure definitions. When you request the `paying_percentage`
measure via an API, the following SQL will be generated:

```sql
SELECT
  100.0 * count(
    CASE WHEN (users.paying = 'true') THEN users.id END
  ) / count(users.id) "users.paying_percentage"
FROM users
```

As with other measures, `paying_percentage` can be used with dimensions.

In the next step, we'll learn more about [how to query
Cube][ref-getting-started-oss-query-cube].

[ref-backend-restapi]: /rest-api
[ref-getting-started-oss-query-cube]: /getting-started/core/query-cube-api
[ref-schema-cube]: /schema/reference/cube
[ref-schema-measures]: /schema/reference/measures
[ref-schema-dimensions]: /schema/reference/dimensions
[ref-schema-types-formats]: /schema/reference/types-and-formats
[ref-examples]: /examples
[ref-backend-query-format]: /query-format
